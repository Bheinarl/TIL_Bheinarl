# Algorithm

[Algorithm](#algorithm-알고리즘)   
[시간 복잡도](#시간-복잡도)   
[복잡도 분석](#복잡도-분석)   

[진수(진법)](#진수진법)   
[진법 변환](#진법-변환)   

---

## Algorithm 알고리즘
- 유한한 단계를 통해 **문제를 해결하기 위한 절차나 방법**

- 주로 컴퓨터 용어로 쓰임

- 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법

- 어떠한 문제를 해결하기 위한 절차

### 컴퓨터 분야에서 알고리즘 표현법
- 의사코드(슈도코드, Pseudocode)

- 순서도

### 좋은 알고리즘 기준
- 정확성
  - 얼마나 정확하게 동작하는가

- 작업량
  - 얼마나 적은 연산으로 원하는 결과를 얻어내는가

- 메모리 사용량
  - 얼마나 적은 메모리를 사용하는가

- 단순성
  - 얼마나 단순한가

- 최적성
  - 더 이상 개선할 여지없이 최적화되었는가

## 시간 복잡도
- 실제 걸리는 시간을 측정

- 실행되는 명령문의 개수를 계산

### 시간 복잡도 빅-오(O) 표기법
- 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시

- 계수는 생략하여 표시

> O(3n+2) = O(3n) = O(n)
> 최고차항(3n)만 선택 -> 계수 3 제거

- n개의 데이터르 입력받아 저장한 후 각 데이터에 1씩 증가시킨 후 각 데이터를 화면에 출력하는 알고리즘 시간 복잡도

## 복잡도 분석

### 알고리즘

- 유한한 단계를 통해 **문제를 해결하기 위한 절차나 방법**

- 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법

- 어떠한 문제를 해결하기 위한 절차

### 알고리즘의 효율

- 공간적 효율성과 시간적 효율성
    - 공간적 효율성은 연산량 대비 얼마나 **적은 메모리 공간**을 요하는 가
    
    - 시간적 효율성은 연산량 대비 얼마나 **적은 시간**을 요하는 가
    
    - 효율성을 뒤집어 표현하면 복잡도(Complexity)가 된다.
    
    - 복잡도가 높을수록 효율성은 저하된다.

### 복잡도의 점근적 표기

- 시간(또는 공간) 복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러 개의 항을 가지는 다항식이다.

- 이를 단순한 함수로 표현하기 위해 점근적 표기 (Asymptotic Notation)를 사용한다.

- 입력 크기 n이 무한대로 커질 떄의 복잡도를 간단히 표현하기 위해 사용하는 표기법이다.

- **O(Big-Oh) 표기**

- Ω(Big-Omega) 표기

- Θ(Big-Theta) 표기

### O(Big-Oh) 표기

- O-표기는 복잡도의 점근적 상한을 나타낸다.

- 복잡도가 f(n) = 2 * n**2 - 7 * n + 4 라면, f(n)의 O-표기는 O(n**2)다.

- 먼저 f(n)의 단순화된 표현은 n**2이다.

- 단순화된 함수 n**2에 임의의 상수 c를 곱한 c * n**2이 n이 증가함에 따라 f(n)의 상한이 된다. (단, c > 0)

- O(5N) 이렇게 표기하기도 한다.

- 알고리즘 성능을 논문같이 미세하게 비교하고 싶은 경우 배수를 강조하여 표현

### 자주 사용하는 O-표기

- O(1) - 상수 시간 (Constant time)

- **O(log n) - 로그(대수) 시간 (Logarithmic time)**
    - log의 밑 수는 10이 아니라 2이다.

- O(n) - 선형 시간 (Linear time)

- **O(n * log n) - 로그 선형 시간 (Log-linear time)**
    - log의 밑 수는 10이 아니라 2이다.

- O(n**2) - 제곱 시간 (Quadratic time)

- O(n**3) - 세제곱 시간 (Cubic time)

### 복잡도 성능

- O(log n)은 O(1)보다는 느리지만, 유사한 성능을 보인다.

- O(n * log n)은 O(n)보다는 느리지만, 유사한 성능을 보인다.

### 효율적인 알고리즘이 필요한 이유

- 10억 개의 숫자를 정렬하는데 PC에서 O(n**2) 알고리즘은 300여 년이 걸리는 반면, O(n * log n) 알고리즘은 5분만에 정렬한다.

- 효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있다.

- 값 비싼 H/W 기술 개발보다 효율적인 알고리즘 개발이 훨씬 더 경제적이다.

## 진수(진법)

### 2진수, 8진수, 10진수, 16진수

- **2진수**
    - **컴퓨터가 사용하는 진수**
    
    - 수 하나를 0, 1로 표현

- 8진수
    - 2진수를 더 가독성 있께 사용

- **10진수**
    - **사람이 사용하는 진수**
    
    - 수 하나를 0 ~ 9로 표현

- **16진수**
    - **2진수를 더 가독성 있게 사용**
    
    - 수 하나를 0, 1, … , 8, 9, A, B, C, D, E, F로 표현

### 16진수 사용 이유

- 2진수를 사람이 이해하기 편하도록 10진수로 변환
    - 인간이 이해하기 편하지만, **연산이 오래 걸림**

- 2진수를 사람이 이해하기 편하도록 16진수로 변환
    - 인간이 이해하기 어렵지만, **연산 속도가 매우 빠름**

## 진법 변환

### 10진수를 다른 진수로 변환

- 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다.

- (149)_10 = (10010101)_2 = (225)_8 = (95)_16

### 10진수를 2진수로 변환 구현

- 10진수를 지속적으로 2로 나누어 구현한다.

- 마지막으로 List를 거꾸로 뒤집는다.

### 16진수, 2진수 변환

- 2진수, 10진수 간 변환은 연산이 많으나 2진수, 16진수 간 변환은 연산이 없다.

- 진법 변환을 빠르게 할 수 있으려면 우측 진수 표를 암기하는 것을 권장