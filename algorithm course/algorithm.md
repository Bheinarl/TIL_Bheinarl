# Algorithm

[Algorithm](#algorithm-알고리즘)   
[시간 복잡도](#시간-복잡도)   
[복잡도 분석](#복잡도-분석)   

[진수(진법)](#진수진법)   
[진법 변환](#진법-변환)   
[비트 연산](#비트-연산)   
[실수](#실수)   

---

## Algorithm 알고리즘
- 유한한 단계를 통해 **문제를 해결하기 위한 절차나 방법**

- 주로 컴퓨터 용어로 쓰임

- 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법

- 어떠한 문제를 해결하기 위한 절차

### 컴퓨터 분야에서 알고리즘 표현법
- 의사코드(슈도코드, Pseudocode)

- 순서도

### 좋은 알고리즘 기준
- 정확성
  - 얼마나 정확하게 동작하는가

- 작업량
  - 얼마나 적은 연산으로 원하는 결과를 얻어내는가

- 메모리 사용량
  - 얼마나 적은 메모리를 사용하는가

- 단순성
  - 얼마나 단순한가

- 최적성
  - 더 이상 개선할 여지없이 최적화되었는가

## 시간 복잡도
- 실제 걸리는 시간을 측정

- 실행되는 명령문의 개수를 계산

### 시간 복잡도 빅-오(O) 표기법
- 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시

- 계수는 생략하여 표시

> O(3n+2) = O(3n) = O(n)
> 최고차항(3n)만 선택 -> 계수 3 제거

- n개의 데이터르 입력받아 저장한 후 각 데이터에 1씩 증가시킨 후 각 데이터를 화면에 출력하는 알고리즘 시간 복잡도

## 복잡도 분석

### 알고리즘

- 유한한 단계를 통해 **문제를 해결하기 위한 절차나 방법**

- 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법

- 어떠한 문제를 해결하기 위한 절차

### 알고리즘의 효율

- 공간적 효율성과 시간적 효율성
    - 공간적 효율성은 연산량 대비 얼마나 **적은 메모리 공간**을 요하는 가
    
    - 시간적 효율성은 연산량 대비 얼마나 **적은 시간**을 요하는 가
    
    - 효율성을 뒤집어 표현하면 복잡도(Complexity)가 된다.
    
    - 복잡도가 높을수록 효율성은 저하된다.

### 복잡도의 점근적 표기

- 시간(또는 공간) 복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러 개의 항을 가지는 다항식이다.

- 이를 단순한 함수로 표현하기 위해 점근적 표기 (Asymptotic Notation)를 사용한다.

- 입력 크기 n이 무한대로 커질 떄의 복잡도를 간단히 표현하기 위해 사용하는 표기법이다.

- **O(Big-Oh) 표기**

- Ω(Big-Omega) 표기

- Θ(Big-Theta) 표기

### O(Big-Oh) 표기

- O-표기는 복잡도의 점근적 상한을 나타낸다.

- 복잡도가 f(n) = 2 * n**2 - 7 * n + 4 라면, f(n)의 O-표기는 O(n**2)다.

- 먼저 f(n)의 단순화된 표현은 n**2이다.

- 단순화된 함수 n**2에 임의의 상수 c를 곱한 c * n**2이 n이 증가함에 따라 f(n)의 상한이 된다. (단, c > 0)

- O(5N) 이렇게 표기하기도 한다.

- 알고리즘 성능을 논문같이 미세하게 비교하고 싶은 경우 배수를 강조하여 표현

### 자주 사용하는 O-표기

- O(1) - 상수 시간 (Constant time)

- **O(log n) - 로그(대수) 시간 (Logarithmic time)**
    - log의 밑 수는 10이 아니라 2이다.

- O(n) - 선형 시간 (Linear time)

- **O(n * log n) - 로그 선형 시간 (Log-linear time)**
    - log의 밑 수는 10이 아니라 2이다.

- O(n**2) - 제곱 시간 (Quadratic time)

- O(n**3) - 세제곱 시간 (Cubic time)

### 복잡도 성능

- O(log n)은 O(1)보다는 느리지만, 유사한 성능을 보인다.

- O(n * log n)은 O(n)보다는 느리지만, 유사한 성능을 보인다.

### 효율적인 알고리즘이 필요한 이유

- 10억 개의 숫자를 정렬하는데 PC에서 O(n**2) 알고리즘은 300여 년이 걸리는 반면, O(n * log n) 알고리즘은 5분만에 정렬한다.

- 효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있다.

- 값 비싼 H/W 기술 개발보다 효율적인 알고리즘 개발이 훨씬 더 경제적이다.

## 진수(진법)

### 2진수, 8진수, 10진수, 16진수

- **2진수**
    - **컴퓨터가 사용하는 진수**
    
    - 수 하나를 0, 1로 표현

- 8진수
    - 2진수를 더 가독성 있께 사용

- **10진수**
    - **사람이 사용하는 진수**
    
    - 수 하나를 0 ~ 9로 표현

- **16진수**
    - **2진수를 더 가독성 있게 사용**
    
    - 수 하나를 0, 1, … , 8, 9, A, B, C, D, E, F로 표현

### 16진수 사용 이유

- 2진수를 사람이 이해하기 편하도록 10진수로 변환
    - 인간이 이해하기 편하지만, **연산이 오래 걸림**

- 2진수를 사람이 이해하기 편하도록 16진수로 변환
    - 인간이 이해하기 어렵지만, **연산 속도가 매우 빠름**

## 진법 변환

### 10진수를 다른 진수로 변환

- 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다.

- (149)_10 = (10010101)_2 = (225)_8 = (95)_16

### 10진수를 2진수로 변환 구현

- 10진수를 지속적으로 2로 나누어 구현한다.

- 마지막으로 List를 거꾸로 뒤집는다.

### 16진수, 2진수 변환

- 2진수, 10진수 간 변환은 연산이 많으나 2진수, 16진수 간 변환은 연산이 없다.

- 진법 변환을 빠르게 할 수 있으려면 우측 진수 표를 암기하는 것을 권장

## 비트 연산

### 비트와 바이트

- 1 bit : 0과 1을 표현하는 정보의 단위

- 1 Byte : 8 bit를 묶어 1 Byte라고 한다.

### 비트 연산

- 컴퓨터의 CPU는 0과 1로 다루어 동작되며, 내부적으로 비트 연산을 사용하여 덧셈, 뺄셈, 곱셈 등을 계산한다.

### 배트 연산 챕터의 목적

- 사람이 사용하는 사칙연산 (+, -, *, /)이 아닌 컴퓨터가 사용하는 연산인 ‘**비트 연산**’을 이해해본다.

- 더 나아가, **프로그래밍에서 비트 연산을 활용한 코딩 방법을 익혀본다.**

### AND와 OR 비트 연산자

- a AND b : a, b 둘 다 1일때만 결과가 1이다. 그 외에는 0

- a OR b : a, b 둘 중 하나만 1이면 결과가 1이다. 그 외에는 0

- &
    - 비트 단위로 AND 연산을 한다.
    
    - 예) num1 & num2

- |  ( shift + \ )
    - 비트 단위로 OR 연산을 한다.
    
    - 예) num1 | num2

- 파이썬 구현
    - 7 & 5 : 이진수로 표현하면 0b111 & 0b101, 5
    
    - 7 | 5 : 이진수로 표현하면 0b111 | 0b101, 7

### 파이썬으로 2진수, 10진수, 16진수 변환

- 2진수는 숫자 0과 소문자 b → 0b를 접두사로 붙여 표현

- 16진수는 숫자 0과 소문자 x → 0x를 접두사로 붙여 표현

```python
print(bin(10))  # 0b1010
print(hex(10))  # 0xa

print(int('1011',2))  # 11, 2진수를 10진수로
print(int('b', 16))   # 11, 16진수를 10진수로

0b11011110 & 0b11011
# 자리수를 맞춰서 0b11011110 & 0b00011011로 계산
# 0b11010 = 26

0x4A3 | 25_(10)
# 0x4A3 = 0b 0100 1010 0011
# 25_(10) = 0b 0000 0001 1001
# 0x4A3 | 25_(10) = 0b 0100 1011 1011 = 1211_(10)
```

### XOR 와 NOT 연산자

- ^
    - XOR(엑스오어)연산자
    
    - OR처럼 동작되는데 둘 다 1인 경우는 0이다.
    
    - 같으면 0, 다르면 1
    
    - 어떤 값이던 특정 수로 2회 XOR 하면 원래 수로 돌아온다.
        
        ```python
        7070 ^ 1004 = 6258
        6258 ^ 1004 = 7070
        ```
        
    
    - 이 특성을 이용하여 암호화에 사용됨

### 비트 연산자

- Left Shift <<
    - 특정 수 만큼 비트를 왼쪽으로 밀어낸다.
    
    - 피연산자의 비트 열을 왼쪽으로 이동시킨다.

- Right Shift >>
    - 특정 수 만큼 비트를 오른쪽으로 밀어낸다. (우측 비트들이 제거된다.)
    
    - 피연산자의 비트 열을 오른쪽으로 이동시킨다.

- 1 << n
    - 2**n의 값을 갖는다.
    
    - 부분집합의 개수를 알수 있다.
    
    - 부분 집합의 수 : `1 << len(arr)`
    
    - 각 자리를 쓴다 / 안쓴다 → 나올 수 있는 경우의 수 = 2가지
    
    - 각 자리마다 2가지 경우의 수 → N 길이라면 → 2 ** N 만큼의 경우의 수가 나온다.

- i & (1<<n)
    - i의 n번째 비트가 1인지 아닌지를 확인할 수 있다.
    
    - ex ) 1101 & (1 << 2)
        - 1101에서 **2번 bit**가 1인지 확인 가능하다. (결과값 = 0100)
        
        - 결과값이 0보다 크면 n번째 비트는 1임이 확정

### 음수 표현 방법

- 컴퓨터는 음수를 “2의 보수”로 관리한다.

- 맨 앞자리 bit (MSB)는 음수 or 양수를 구분하는 비트이다.

- 컴퓨터가 2의 보수를 사용하여 음수를 관리하는 이유
    - 뺄셈의 연산 속도를 올릴 수 있으며, +0과 -0을 따로 취급하지 않기 위해 사용한다.

### 2의 보수

- 2의 보수를 구하려면 이진수의 수를 모두 뒤집고 +1 을 한다.

- 예시) 10001
    - 01110 + 1 = 01111

- 2의 보수를 취한 수를 한번 더 2의 보수를 취하면 원래 값으로 돌아온다.

### NOT 연산자

- ( ~ ) NOT 연산자 : 모든 비트를 반전시킨다.

- 만약 8 bit 일 때 ~(0001 1111) 이라면 값은 1110 0000 이 된다.

- 파이썬이 ~4를 -5로 출력하는 과정
    - 4는 0b**0**100이다. (**MSB** : 양수이므로 0)
    
    - NOT 연산자로 인해 뒤집으면 1011이 된다.
    
    - MSB는 1이 되었고(음수), 나머지 bit는 011이다.
    
    - 나머지 bit에 대해 2의 보수를 취하면 100 + 1 = 101이 되므로 5가 된다.
    
    - 따라서 -5가 된다.

## 실수

### 파이썬 실수 출력 방법

- 파이썬은 f-string 문법을 지향

- `print(f'{ }')`

### 소수점 출력 방법

- t2 값을 소수점 둘째자리에서 **반올림**하여 표현

- `print(f'{ .2f}')`
    
    ```python
    t2 = 3.141592
    print(f'변수 {t2:.2f}')  # 변수 3.14
    ```
    

### 파이썬에서의 실수 표현 범위

- 파이썬에서는 다른 언어와 달리 내부적으로 더 큰 규모의 자료 구조를 사용해서 훨씬 넓은 범위의 실수를 표현할 수 있다.

- 최대로 표현할수 있는 값은 약 1.8 * 10**308이고, 이 이상은 inf로 표현

- 최소로 표현할수 있는 값은 약 5.0 * 10 **(-324)이며, 이 이하는 0으로 표현

- 컴퓨터는 실수를 내부적으로 근사적으로 관리한다.

- 실수는 정확한 값이 아니라 근사 값을 저장하는데 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져온다.
    
    ```python
    print(0.1 + 0.1 + 0.1 == 0.3)  # False
    #비트로 표현하면 무한 반복되는 숫자끼리 더하기 때문에 오차가 발생한다.
    ```
    

### 소수점이 있는 10진수를 2진수로 변환

- 0.75
    - 0.75 = 2 **(-1) + 2 **(-2) = 0.11_(2)

- 0.40625
    - 0.40625 = 2 **(-2) + 2**(-3) + 2**(-5) = 0.01101_(2)

### 실수의 표현

- 컴퓨터는 실수를 표현하기 위해 부동 소수점(floating-point) 표기법을 사용한다.

- 이 표기법은 **IEEE 754**(IEEE(표준 만드는 협회 이름) 754(버전) ) 이라는 컴퓨터에서 부동 소수점을 표기하는 국제 표준

- 부동 소수점 표기 방법은 소수점의 위치를 고정시켜 표현하는 방식

- 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑 수의 지수승으로 표현

- ex) 1001.0011 = 1.0010011 * 2**3

### 실수를 저장하기 위한 형식

- 32bit 구조
    - 부호 1비트 + 지수 8비트 + 가수 23비트

- 부호 1비트 : 0이면 양수, 1이면 음수

- 지수부(exponent) : 부동소수점의 크기 + bias값

- 가수부(mantissa) : 실질적 수

- 12.375를 부동 소수점으로 표기
    - 12.375를 2진수로 변환 : 12는 1100_(2), 0.375는 0.011_(2)이므로 1100.011_(2)
    
    - 1100.011_(2) = 1.100011 * 2**3
    
    - 즉, 가수는 100011이고 지수는 3 (맨 앞 1은 생략)
    
    - 지수 + bias : IEEE754는 bias를 더한 결과로 표기
        - 3 + 127(bias) = 130 (2진수로는 10000010)
    
    - 12.375를 IEEE754로 표기하는 방법
        - 부호 비트 : 0 (양수)
        
        - 지수 : 10000010
        
        - 가수 : 10001100000000000000000

### 컴퓨터는 실수를 근사적으로 표현

- 이진법으로 표현할 수 없는 형태의 실수는 정확한 값이 아니라 근사 값으로 저장되는데 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져온다.

### 실수 자료형의 유효 자릿수를 알아 두자.

- 32 비트 실수형 유효자릿수(십진수) → 약 6자리 (C++)

- 64 비트 실수형 유효 자릿수(십진수) → 약 15ㅈ리 (C++, Java)

- 파이썬에서는 내부적으로 더 많은 비트를 사용해서 훨씬 넓은 범위의 실수를 표현할 수 있다.