# Stack

[Stack](#stack-1)   
[Stack의 구현](#stack의-구현)   
[Stack의 응용](#stack의-응용)   
[재귀 호출](#재귀-호출)   

---
## Stack
### Stack의 특성
- 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료 구조

- 스택에 저장된 자료는 **선형 구조**를 갖는다.
  - 선형 구조 : 자료 간의 관계가 1대1 관계를 갖는다.
  
  - 비선형 구조 : 자료 간의 관계가 1대N 관계를 갖는다.

- 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있다.

- 마지막에 삽입한 자료를 가장 먼저 꺼낸다.

- **후입선출**(LIFO, Last In First Out)이라고 부른다.
  - 예를 들어 스택에 1, 2, 3 순으로 자료를 삽입한 후 꺼내면 역순으로 <br/>즉, 3, 2, 1 순으로 꺼낼 수 있다.

## Stack의 구현
### Stack을 프로그램에서 구현하기 위해서 필요한 자료 구조와 연산
- 자료 구조 : 자료를 선형으로 저장할 저장소
  - 배열을 사용할 수 있다.
  
  - 저장소 자체를 스택이라 부르기도 한다.
  
  
  - 스택에서 마지막 삽입(저장)된 원소의 위치를 top이라 부른다.

- 연산
  - 삽입 : 저장소에 자료를 저장한다. 보통 push라고 부른다.
  
  - 삭제 : 저장소에 자료를 꺼낸다. 꺼낸 자료는 삽입한 자료의 역순으로 꺼낸다. <br />보통 pop이라고 부른다.
  
  - 스택이 공백인지 아닌지를 확인하는 연산 : isEmpty
  
  - 스택의 top에 있는 item(원소)을 반환하는 연산 : peek

### Stack의 삽입 / 삭제 과정
- 빈 스택에 원소 A, B, C를 차례로 삽입 후 한번 삭제하는 연산 과정

  ![스택의삽입삭제과정](./images/스택의삽입삭제과정_1.png)

### Stack의 push 알고리즘
- 스택을 활용한 복잡한 알고리즘은 전체 구조 파악이 우선

- `append`메소드를 통해 리스트의 마지막에 데이터를 삽입

```python
def push(item):
  s.append(item)
```

```python
def push(item, size):
	global top
	top += 1
	if top == size:  # 디버깅용 코드 느낌이 강함
		print('overflow!')  # 데이터 입력이 사이즈를 초과함
	else:
		stack[top] = item

size = 10
stack = [0] * size
top = -1

push(10, size)
top += 1         # push(20)
stack[top] = 20  # 
```

### Stack의 pop 알고리즘

```python
def my_pop():
	if len(s) == 0:
		# underflow, 데이터가 없는데 꺼내려 함
		return
	else:
		return s.pop()
```

```python
def pop():
	global top
	if top == -1:
		print('underflow')
		return 0
	else:
		top -= 1  # 지우는 건 의미 없음
		return stack[top+1]
		
print(pop())
```

```python
if top > -1: # pop()   데이터가 남아있다면 꺼냄
	top -= 1
	print(stack[top+1])
```

```python
while top > -1:
	v = stack[pop]
	top -= 1
```

## Stack의 응용
### Stack 구현 고려 사항
- 1차원 배열을 사용하여 구현할 경우 구현이 용이하다는 장점이 있지만, 스택의 크기를 변경하기가 어렵다는 단점이 있음

- 해결 방법
  - 저장소를 동적으로 할당하여 스택을 구현하는 방법
  
  - 동적 연결 리스트를 이용하여 구현하는 방법
  
  - 스택의 동적 구현은 생략함
  
  - 장점 : 메모리를 효율적으로 사용한다.
  
  - 단점 : 구현이 복잡하다.

### 괄호 검사
- 괄호의 종류
  - 대괄호 [ ]
  
  - 중괄호 { }
  
  - 소괄호 ( )

- 조건
  - 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다.
  
  - 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다.
  
  - 괄호 사이에 포함 관계만 존재한다.

- 잘못된 괄호 사용의 예시
  - (a(b)
  
  - a(b)c)
  
  - a{b(c[d]e}f)

- 스택을 이용한 괄호 검사
  - 여는 괄호를 만나면 push, 닫는 괄호를 만나면 pop
  
  - 짝이 맞는지 (개수가 맞는지) 확인
  
  ![괄호검사_1](./images/괄호검사_1.png)

- 괄호를 조사하는 알고리즘 개요
  - 문자열에 있는 괄호를 차례대로 조사하면서 여는 괄호를 만나면 스택에 삽입(push)
  
  - 이 때 스택이 비어 있으면 <조건 1> 또는 <조건 2>에 위배되고, 괄호의 짝이 맞지 않으면 <조건 3>에 위배
  
  - 마지막 괄호까지를 조사한 후에도 스택에 괄호가 남아 있으면 <조건 1>에 위배된다.

### function call
- 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리
  - 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조
  
  - 후입선출 구조의 스택을 이용하여 수행 순서를 관리
  
  ![functioncall_1](./images/functioncall_1.png)
  
  - 함수 호출이 발생하면 호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임(Stack Frame)에 저장하여 시스템 스택에 삽입
  
  ![functioncall_2](./images/functioncall_2.png)
  
  - 함수의 실행이 끝나면 시스템 스택의 top 원소(스택 프레임, Stack Frame)를 삭제(pop)하면서 프레임에 저장되어 있던 복귀 주소를 확인하고 복귀
  
  - 함수 호출과 복귀에 따라 이 과정을 반복하여 전체 프로그램 수행이 종료되면 시스템 스택은 공백 스택이 됨

## 재귀 호출
### 재귀 호출
- 필요한 함수가 자신과 같은 경우 자신을 다시 호출하는 구조

- 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출 방식보다 재귀 호출 방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성

- 재귀 호출의 예시
  - factorial
  
  - 피보나치 수열

### factorial 함수
- n에 대한 factorial : 1부터 n까지의 모든 자연수를 곱하여 구하는 연산
  ```python
  n! = n * (n-1)!
	  (n-1)! = (n-1) * (n-2)!
		  (n-2)! = (n-2) * (n-3)!
		  	...
		  		2! = 2 * 1!
			  		1! = 1
  ```

- factorial 함수에서 n = 4인 경우의 실행
  ![factorial 함수_1](./images/factorial함수_1.png)

### 피보나치 수열
- 0과 1로 시작하고 이전의 두 수 합을 다음 항으로 하는 수열을 피보나치라 한다.
  - 0, 1, 1, 2, 3, 5, 8, 13, ...

- 피보나치 수열의 i번째 값을 계산하는 함수 F를 정의하면 다음과 같다.
  $$ F_0\,=\,0,\,F_1\,=\,1 $$
  $$ F_i\,=\,F_(i-1)\,+\,F_(i-2)\,for\,i\,\geq\,2 $$

- 위의 정의로부터 피보나치 수열의 i번째 항을 반환하는 함수를 재귀 함수로 구현할 수 있다.

- 피보나치 수를 구하는 재귀함수

```python
def fibo(n):  # f(0) = 0, f(1) = 1
  if n < 2:
    return n
  else:
    return fibo(n-1) + fibo(n-2)
```

### 재귀 호출 연습

- 모든 배열 원소에 접근하기

  ```python
  def f(i, N):  # i는 접근할 원소 인덱스, N은 크기
   if i == N:
     return
   else:  # else 없어도 상관 없음
     print(arr[i])
     f(i+1, N)
      return
  arr = [1, 2, 3]
  N = 3
  f(0, 3)
  ```
  
  - 아래 사진과 같이 데이터를 왼쪽 화살표처럼 한 칸씩 내려가면서 받고 저장
    
  - 다 저장되면 다시 올라오면서 위 쪽 데이터 공간에 저장
   
    <div align='center'>

    ![재귀호출연습_1](./images/재귀호출연습_1.png)

    </div>
   
- 배열에 v가 있으면 1, 없으면 0을 리턴
  
  - v = 3인 경우
  ```python
  def f(i, N, v):  # v는 찾는 값
    if i == N:
      return 0
    elif arr[i] == v:
      return 1
    else:
      return j(i+1, N)
  ```

  <div align='center'>

    ![재귀호출연습_2](./images/재귀호출연습_2.png)

    </div>
